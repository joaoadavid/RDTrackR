//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.6.2.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* eslint-disable */
// ReSharper disable InconsistentNaming

export interface IApiClient {

    /**
     * @param body (optional) 
     * @return Created
     */
    create(body?: RequestAdminCreateUserJson | undefined, signal?: AbortSignal): Promise<ResponseAdminCreateUserJson>;

    /**
     * @return OK
     */
    adminAll(signal?: AbortSignal): Promise<ResponseUserListItemJson[]>;

    /**
     * @param body (optional) 
     * @return No Content
     */
    adminPUT(id: number, body?: RequestAdminUpdateUserJson | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @return No Content
     */
    adminDELETE(id: number, signal?: AbortSignal): Promise<void>;

    /**
     * @return No Content
     */
    toggle(id: number, signal?: AbortSignal): Promise<void>;

    /**
     * @param type (optional) 
     * @param search (optional) 
     * @return OK
     */
    logs(type?: string | undefined, search?: string | undefined, signal?: AbortSignal): Promise<ResponseAuditLogJson[]>;

    /**
     * @param body (optional) 
     * @return OK
     */
    contact(body?: RequestContactJson | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @param body (optional) 
     * @return OK
     */
    login(body?: RequestLoginJson | undefined, signal?: AbortSignal): Promise<ResponseRegisterUserJson>;

    /**
     * @param body (optional) 
     * @return No Content
     */
    logout(body?: string | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @return Accepted
     */
    codeResetPassword(email: string, signal?: AbortSignal): Promise<void>;

    /**
     * @param body (optional) 
     * @return No Content
     */
    resetPassword(body?: RequestResetYourPasswordJson | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @param body (optional) 
     * @return No Content
     */
    validateResetCode(body?: RequestValidateResetCodeJson | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param warehouseId (optional) 
     * @param type (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return OK
     */
    movementGET(page?: number | undefined, pageSize?: number | undefined, warehouseId?: number | undefined, type?: MovementType | undefined, startDate?: Date | undefined, endDate?: Date | undefined, signal?: AbortSignal): Promise<ResponseMovementJsonPagedResponse>;

    /**
     * @param body (optional) 
     * @return Created
     */
    movementPOST(body?: RequestRegisterMovementJson | undefined, signal?: AbortSignal): Promise<ResponseMovementJson>;

    /**
     * @return OK
     */
    notifications(signal?: AbortSignal): Promise<ResponseNotificationJson[]>;

    /**
     * @return OK
     */
    read(id: number, signal?: AbortSignal): Promise<void>;

    /**
     * @param body (optional) 
     * @return Created
     */
    ordersPOST(body?: RequestCreateOrderJson | undefined, signal?: AbortSignal): Promise<ResponseOrderJson>;

    /**
     * @return OK
     */
    ordersAll(signal?: AbortSignal): Promise<ResponseOrderJson[]>;

    /**
     * @param body (optional) 
     * @return No Content
     */
    status(id: number, body?: RequestUpdateOrderStatusJson | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @return No Content
     */
    ordersDELETE(id: number, signal?: AbortSignal): Promise<void>;

    /**
     * @param body (optional) 
     * @return Created
     */
    register(body?: RequestRegisterOrganizationJson | undefined, signal?: AbortSignal): Promise<ResponseRegisterOrganizationJson>;

    /**
     * @return OK
     */
    overview(signal?: AbortSignal): Promise<ResponseOverviewJson>;

    /**
     * @param body (optional) 
     * @return Created
     */
    productPOST(body?: RequestRegisterProductJson | undefined, signal?: AbortSignal): Promise<ResponseProductJson>;

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param search (optional) 
     * @return OK
     */
    productGET(page?: number | undefined, pageSize?: number | undefined, search?: string | undefined, signal?: AbortSignal): Promise<ResponseProductJsonPagedResponse>;

    /**
     * @return OK
     */
    productGET2(id: number, signal?: AbortSignal): Promise<ResponseProductJson>;

    /**
     * @param body (optional) 
     * @return No Content
     */
    productPUT(id: number, body?: RequestRegisterProductJson | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @return No Content
     */
    productDELETE(id: number, signal?: AbortSignal): Promise<void>;

    /**
     * @param body (optional) 
     * @return Created
     */
    purchaseorderPOST(body?: RequestCreatePurchaseOrderJson | undefined, signal?: AbortSignal): Promise<ResponsePurchaseOrderJson>;

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param status (optional) 
     * @param search (optional) 
     * @return OK
     */
    purchaseorderGET(page?: number | undefined, pageSize?: number | undefined, status?: string | undefined, search?: string | undefined, signal?: AbortSignal): Promise<ResponsePurchaseOrderJsonPagedResponse>;

    /**
     * @return OK
     */
    purchaseorderGET2(id: number, signal?: AbortSignal): Promise<ResponsePurchaseOrderJson>;

    /**
     * @return No Content
     */
    purchaseorderDELETE(id: number, signal?: AbortSignal): Promise<void>;

    /**
     * @param body (optional) 
     * @return OK
     */
    status2(id: number, body?: RequestUpdatePurchaseOrderStatusJson | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @param body (optional) 
     * @return No Content
     */
    items(id: number, body?: RequestUpdatePurchaseOrderItemsJson | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param search (optional) 
     * @return OK
     */
    replenishment(page?: number | undefined, pageSize?: number | undefined, search?: string | undefined, signal?: AbortSignal): Promise<ResponseReplenishmentItemJsonPagedResponse>;

    /**
     * @param body (optional) 
     * @return Created
     */
    generatePo(body?: RequestGeneratePoFromReplenishmentJson | undefined, signal?: AbortSignal): Promise<ResponsePurchaseOrderJson>;

    /**
     * @return OK
     */
    reports(signal?: AbortSignal): Promise<ResponseReportsJson>;

    /**
     * @param body (optional) 
     * @return Created
     */
    stockitem(body?: RequestRegisterStockItemJson | undefined, signal?: AbortSignal): Promise<ResponseStockItemJson>;

    /**
     * @return OK
     */
    stockitemAll(signal?: AbortSignal): Promise<ResponseStockItemJson[]>;

    /**
     * @param body (optional) 
     * @return Created
     */
    supplierPOST(body?: RequestRegisterSupplierJson | undefined, signal?: AbortSignal): Promise<ResponseSupplierJson>;

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param search (optional) 
     * @return OK
     */
    supplierGET(page?: number | undefined, pageSize?: number | undefined, search?: string | undefined, signal?: AbortSignal): Promise<ResponseSupplierJsonPagedResponse>;

    /**
     * @param body (optional) 
     * @return OK
     */
    supplierPUT(id: number, body?: RequestUpdateSupplierJson | undefined, signal?: AbortSignal): Promise<ResponseSupplierJson>;

    /**
     * @return No Content
     */
    supplierDELETE(id: number, signal?: AbortSignal): Promise<void>;

    /**
     * @param body (optional) 
     * @return Created
     */
    productsPOST(supplierId: number, body?: RequestRegisterSupplierProductJson | undefined, signal?: AbortSignal): Promise<ResponseSupplierProductJson>;

    /**
     * @return OK
     */
    productsAll(supplierId: number, signal?: AbortSignal): Promise<ResponseSupplierProductJson[]>;

    /**
     * @param body (optional) 
     * @return OK
     */
    productsPUT(supplierId: number, productId: number, body?: RequestUpdateSupplierProductJson | undefined, signal?: AbortSignal): Promise<ResponseSupplierProductJson>;

    /**
     * @return No Content
     */
    productsDELETE(supplierId: number, productId: number, signal?: AbortSignal): Promise<void>;

    /**
     * @param body (optional) 
     * @return OK
     */
    refreshToken(body?: RequestNewTokenJson | undefined, signal?: AbortSignal): Promise<ResponseTokensJson>;

    /**
     * @param body (optional) 
     * @return Created
     */
    userPOST(body?: RequestRegisterUserJson | undefined, signal?: AbortSignal): Promise<ResponseRegisterUserJson>;

    /**
     * @return OK
     */
    userGET(signal?: AbortSignal): Promise<ResponseUserProfileJson>;

    /**
     * @param body (optional) 
     * @return No Content
     */
    userPUT(body?: RequestUpdateUserJson | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @return No Content
     */
    userDELETE(signal?: AbortSignal): Promise<void>;

    /**
     * @return OK
     */
    allUsers(signal?: AbortSignal): Promise<ResponseUserProfileJson>;

    /**
     * @param body (optional) 
     * @return No Content
     */
    changePassword(body?: RequestChangePasswordJson | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param search (optional) 
     * @return OK
     */
    warehouseGET(page?: number | undefined, pageSize?: number | undefined, search?: string | undefined, signal?: AbortSignal): Promise<ResponseWarehouseJsonPagedResponse>;

    /**
     * @param body (optional) 
     * @return Created
     */
    warehousePOST(body?: RequestRegisterWarehouseJson | undefined, signal?: AbortSignal): Promise<ResponseWarehouseJson>;

    /**
     * @param body (optional) 
     * @return OK
     */
    warehousePUT(id: number, body?: RequestUpdateWarehouseJson | undefined, signal?: AbortSignal): Promise<ResponseWarehouseJson>;

    /**
     * @return No Content
     */
    warehouseDELETE(id: number, signal?: AbortSignal): Promise<void>;

    /**
     * @return OK
     */
    warehouseGET2(id: number, signal?: AbortSignal): Promise<ResponseWarehouseJson>;

    /**
     * @return OK
     */
    itemsAll(id: number, signal?: AbortSignal): Promise<ResponseWarehouseStockItemJson[]>;
}

export class ApiClient implements IApiClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    create(body?: RequestAdminCreateUserJson | undefined, signal?: AbortSignal): Promise<ResponseAdminCreateUserJson> {
        let url_ = this.baseUrl + "/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<ResponseAdminCreateUserJson> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ResponseAdminCreateUserJson.fromJS(resultData201);
            return result201;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseAdminCreateUserJson>(null as any);
    }

    /**
     * @return OK
     */
    adminAll(signal?: AbortSignal): Promise<ResponseUserListItemJson[]> {
        let url_ = this.baseUrl + "/users/admin";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAdminAll(_response);
        });
    }

    protected processAdminAll(response: Response): Promise<ResponseUserListItemJson[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ResponseUserListItemJson.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseUserListItemJson[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return No Content
     */
    adminPUT(id: number, body?: RequestAdminUpdateUserJson | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/users/admin/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAdminPUT(_response);
        });
    }

    protected processAdminPUT(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return No Content
     */
    adminDELETE(id: number, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/users/admin/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAdminDELETE(_response);
        });
    }

    protected processAdminDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return No Content
     */
    toggle(id: number, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/users/admin/{id}/toggle";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PATCH",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processToggle(_response);
        });
    }

    protected processToggle(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param type (optional) 
     * @param search (optional) 
     * @return OK
     */
    logs(type?: string | undefined, search?: string | undefined, signal?: AbortSignal): Promise<ResponseAuditLogJson[]> {
        let url_ = this.baseUrl + "/auditlog/audit/logs?";
        if (type === null)
            throw new globalThis.Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        if (search === null)
            throw new globalThis.Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogs(_response);
        });
    }

    protected processLogs(response: Response): Promise<ResponseAuditLogJson[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ResponseAuditLogJson.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseAuditLogJson[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    contact(body?: RequestContactJson | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/contact";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processContact(_response);
        });
    }

    protected processContact(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    login(body?: RequestLoginJson | undefined, signal?: AbortSignal): Promise<ResponseRegisterUserJson> {
        let url_ = this.baseUrl + "/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: Response): Promise<ResponseRegisterUserJson> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseRegisterUserJson.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ResponseErrorJson.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseRegisterUserJson>(null as any);
    }

    /**
     * @param body (optional) 
     * @return No Content
     */
    logout(body?: string | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/login/logout";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogout(_response);
        });
    }

    protected processLogout(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Accepted
     */
    codeResetPassword(email: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/login/code-reset-password/{email}";
        if (email === undefined || email === null)
            throw new globalThis.Error("The parameter 'email' must be defined.");
        url_ = url_.replace("{email}", encodeURIComponent("" + email));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCodeResetPassword(_response);
        });
    }

    protected processCodeResetPassword(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 202) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return No Content
     */
    resetPassword(body?: RequestResetYourPasswordJson | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/login/reset-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processResetPassword(_response);
        });
    }

    protected processResetPassword(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ResponseErrorJson.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return No Content
     */
    validateResetCode(body?: RequestValidateResetCodeJson | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/login/validate-reset-code";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processValidateResetCode(_response);
        });
    }

    protected processValidateResetCode(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ResponseErrorJson.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param warehouseId (optional) 
     * @param type (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return OK
     */
    movementGET(page?: number | undefined, pageSize?: number | undefined, warehouseId?: number | undefined, type?: MovementType | undefined, startDate?: Date | undefined, endDate?: Date | undefined, signal?: AbortSignal): Promise<ResponseMovementJsonPagedResponse> {
        let url_ = this.baseUrl + "/movement?";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (warehouseId === null)
            throw new globalThis.Error("The parameter 'warehouseId' cannot be null.");
        else if (warehouseId !== undefined)
            url_ += "WarehouseId=" + encodeURIComponent("" + warehouseId) + "&";
        if (type === null)
            throw new globalThis.Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        if (startDate === null)
            throw new globalThis.Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new globalThis.Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMovementGET(_response);
        });
    }

    protected processMovementGET(response: Response): Promise<ResponseMovementJsonPagedResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseMovementJsonPagedResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseMovementJsonPagedResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    movementPOST(body?: RequestRegisterMovementJson | undefined, signal?: AbortSignal): Promise<ResponseMovementJson> {
        let url_ = this.baseUrl + "/movement";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMovementPOST(_response);
        });
    }

    protected processMovementPOST(response: Response): Promise<ResponseMovementJson> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ResponseMovementJson.fromJS(resultData201);
            return result201;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseMovementJson>(null as any);
    }

    /**
     * @return OK
     */
    notifications(signal?: AbortSignal): Promise<ResponseNotificationJson[]> {
        let url_ = this.baseUrl + "/notifications/notifications";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processNotifications(_response);
        });
    }

    protected processNotifications(response: Response): Promise<ResponseNotificationJson[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ResponseNotificationJson.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseNotificationJson[]>(null as any);
    }

    /**
     * @return OK
     */
    read(id: number, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/notifications/notifications/{id}/read";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRead(_response);
        });
    }

    protected processRead(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    ordersPOST(body?: RequestCreateOrderJson | undefined, signal?: AbortSignal): Promise<ResponseOrderJson> {
        let url_ = this.baseUrl + "/orders";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processOrdersPOST(_response);
        });
    }

    protected processOrdersPOST(response: Response): Promise<ResponseOrderJson> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ResponseOrderJson.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ResponseErrorJson.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseOrderJson>(null as any);
    }

    /**
     * @return OK
     */
    ordersAll(signal?: AbortSignal): Promise<ResponseOrderJson[]> {
        let url_ = this.baseUrl + "/orders";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processOrdersAll(_response);
        });
    }

    protected processOrdersAll(response: Response): Promise<ResponseOrderJson[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ResponseOrderJson.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseOrderJson[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return No Content
     */
    status(id: number, body?: RequestUpdateOrderStatusJson | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/orders/{id}/status";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStatus(_response);
        });
    }

    protected processStatus(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return No Content
     */
    ordersDELETE(id: number, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/orders/orders/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processOrdersDELETE(_response);
        });
    }

    protected processOrdersDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    register(body?: RequestRegisterOrganizationJson | undefined, signal?: AbortSignal): Promise<ResponseRegisterOrganizationJson> {
        let url_ = this.baseUrl + "/organization/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRegister(_response);
        });
    }

    protected processRegister(response: Response): Promise<ResponseRegisterOrganizationJson> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ResponseRegisterOrganizationJson.fromJS(resultData201);
            return result201;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseRegisterOrganizationJson>(null as any);
    }

    /**
     * @return OK
     */
    overview(signal?: AbortSignal): Promise<ResponseOverviewJson> {
        let url_ = this.baseUrl + "/overview";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processOverview(_response);
        });
    }

    protected processOverview(response: Response): Promise<ResponseOverviewJson> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseOverviewJson.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseOverviewJson>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    productPOST(body?: RequestRegisterProductJson | undefined, signal?: AbortSignal): Promise<ResponseProductJson> {
        let url_ = this.baseUrl + "/product";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProductPOST(_response);
        });
    }

    protected processProductPOST(response: Response): Promise<ResponseProductJson> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ResponseProductJson.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ResponseErrorJson.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseProductJson>(null as any);
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param search (optional) 
     * @return OK
     */
    productGET(page?: number | undefined, pageSize?: number | undefined, search?: string | undefined, signal?: AbortSignal): Promise<ResponseProductJsonPagedResponse> {
        let url_ = this.baseUrl + "/product?";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (search === null)
            throw new globalThis.Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProductGET(_response);
        });
    }

    protected processProductGET(response: Response): Promise<ResponseProductJsonPagedResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseProductJsonPagedResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseProductJsonPagedResponse>(null as any);
    }

    /**
     * @return OK
     */
    productGET2(id: number, signal?: AbortSignal): Promise<ResponseProductJson> {
        let url_ = this.baseUrl + "/product/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProductGET2(_response);
        });
    }

    protected processProductGET2(response: Response): Promise<ResponseProductJson> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseProductJson.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ResponseErrorJson.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseProductJson>(null as any);
    }

    /**
     * @param body (optional) 
     * @return No Content
     */
    productPUT(id: number, body?: RequestRegisterProductJson | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/product/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProductPUT(_response);
        });
    }

    protected processProductPUT(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ResponseErrorJson.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return No Content
     */
    productDELETE(id: number, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/product/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProductDELETE(_response);
        });
    }

    protected processProductDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    purchaseorderPOST(body?: RequestCreatePurchaseOrderJson | undefined, signal?: AbortSignal): Promise<ResponsePurchaseOrderJson> {
        let url_ = this.baseUrl + "/purchaseorder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPurchaseorderPOST(_response);
        });
    }

    protected processPurchaseorderPOST(response: Response): Promise<ResponsePurchaseOrderJson> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ResponsePurchaseOrderJson.fromJS(resultData201);
            return result201;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponsePurchaseOrderJson>(null as any);
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param status (optional) 
     * @param search (optional) 
     * @return OK
     */
    purchaseorderGET(page?: number | undefined, pageSize?: number | undefined, status?: string | undefined, search?: string | undefined, signal?: AbortSignal): Promise<ResponsePurchaseOrderJsonPagedResponse> {
        let url_ = this.baseUrl + "/purchaseorder?";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (status === null)
            throw new globalThis.Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (search === null)
            throw new globalThis.Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPurchaseorderGET(_response);
        });
    }

    protected processPurchaseorderGET(response: Response): Promise<ResponsePurchaseOrderJsonPagedResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponsePurchaseOrderJsonPagedResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponsePurchaseOrderJsonPagedResponse>(null as any);
    }

    /**
     * @return OK
     */
    purchaseorderGET2(id: number, signal?: AbortSignal): Promise<ResponsePurchaseOrderJson> {
        let url_ = this.baseUrl + "/purchaseorder/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPurchaseorderGET2(_response);
        });
    }

    protected processPurchaseorderGET2(response: Response): Promise<ResponsePurchaseOrderJson> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponsePurchaseOrderJson.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ResponseErrorJson.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponsePurchaseOrderJson>(null as any);
    }

    /**
     * @return No Content
     */
    purchaseorderDELETE(id: number, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/purchaseorder/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPurchaseorderDELETE(_response);
        });
    }

    protected processPurchaseorderDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    status2(id: number, body?: RequestUpdatePurchaseOrderStatusJson | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/purchaseorder/{id}/status";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStatus2(_response);
        });
    }

    protected processStatus2(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return No Content
     */
    items(id: number, body?: RequestUpdatePurchaseOrderItemsJson | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/purchaseorder/{id}/items";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processItems(_response);
        });
    }

    protected processItems(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param search (optional) 
     * @return OK
     */
    replenishment(page?: number | undefined, pageSize?: number | undefined, search?: string | undefined, signal?: AbortSignal): Promise<ResponseReplenishmentItemJsonPagedResponse> {
        let url_ = this.baseUrl + "/replenishment?";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (search === null)
            throw new globalThis.Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReplenishment(_response);
        });
    }

    protected processReplenishment(response: Response): Promise<ResponseReplenishmentItemJsonPagedResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseReplenishmentItemJsonPagedResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseReplenishmentItemJsonPagedResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    generatePo(body?: RequestGeneratePoFromReplenishmentJson | undefined, signal?: AbortSignal): Promise<ResponsePurchaseOrderJson> {
        let url_ = this.baseUrl + "/replenishment/generate-po";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGeneratePo(_response);
        });
    }

    protected processGeneratePo(response: Response): Promise<ResponsePurchaseOrderJson> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ResponsePurchaseOrderJson.fromJS(resultData201);
            return result201;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponsePurchaseOrderJson>(null as any);
    }

    /**
     * @return OK
     */
    reports(signal?: AbortSignal): Promise<ResponseReportsJson> {
        let url_ = this.baseUrl + "/reports";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReports(_response);
        });
    }

    protected processReports(response: Response): Promise<ResponseReportsJson> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseReportsJson.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseReportsJson>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    stockitem(body?: RequestRegisterStockItemJson | undefined, signal?: AbortSignal): Promise<ResponseStockItemJson> {
        let url_ = this.baseUrl + "/stockitem";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStockitem(_response);
        });
    }

    protected processStockitem(response: Response): Promise<ResponseStockItemJson> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ResponseStockItemJson.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ResponseErrorJson.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseStockItemJson>(null as any);
    }

    /**
     * @return OK
     */
    stockitemAll(signal?: AbortSignal): Promise<ResponseStockItemJson[]> {
        let url_ = this.baseUrl + "/stockitem";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStockitemAll(_response);
        });
    }

    protected processStockitemAll(response: Response): Promise<ResponseStockItemJson[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ResponseStockItemJson.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseStockItemJson[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    supplierPOST(body?: RequestRegisterSupplierJson | undefined, signal?: AbortSignal): Promise<ResponseSupplierJson> {
        let url_ = this.baseUrl + "/supplier";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSupplierPOST(_response);
        });
    }

    protected processSupplierPOST(response: Response): Promise<ResponseSupplierJson> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ResponseSupplierJson.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ResponseErrorJson.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseSupplierJson>(null as any);
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param search (optional) 
     * @return OK
     */
    supplierGET(page?: number | undefined, pageSize?: number | undefined, search?: string | undefined, signal?: AbortSignal): Promise<ResponseSupplierJsonPagedResponse> {
        let url_ = this.baseUrl + "/supplier?";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (search === null)
            throw new globalThis.Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSupplierGET(_response);
        });
    }

    protected processSupplierGET(response: Response): Promise<ResponseSupplierJsonPagedResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseSupplierJsonPagedResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseSupplierJsonPagedResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    supplierPUT(id: number, body?: RequestUpdateSupplierJson | undefined, signal?: AbortSignal): Promise<ResponseSupplierJson> {
        let url_ = this.baseUrl + "/supplier/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSupplierPUT(_response);
        });
    }

    protected processSupplierPUT(response: Response): Promise<ResponseSupplierJson> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseSupplierJson.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ResponseErrorJson.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseSupplierJson>(null as any);
    }

    /**
     * @return No Content
     */
    supplierDELETE(id: number, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/supplier/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSupplierDELETE(_response);
        });
    }

    protected processSupplierDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ResponseErrorJson.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    productsPOST(supplierId: number, body?: RequestRegisterSupplierProductJson | undefined, signal?: AbortSignal): Promise<ResponseSupplierProductJson> {
        let url_ = this.baseUrl + "/supplier/{supplierId}/products";
        if (supplierId === undefined || supplierId === null)
            throw new globalThis.Error("The parameter 'supplierId' must be defined.");
        url_ = url_.replace("{supplierId}", encodeURIComponent("" + supplierId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProductsPOST(_response);
        });
    }

    protected processProductsPOST(response: Response): Promise<ResponseSupplierProductJson> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ResponseSupplierProductJson.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ResponseErrorJson.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseSupplierProductJson>(null as any);
    }

    /**
     * @return OK
     */
    productsAll(supplierId: number, signal?: AbortSignal): Promise<ResponseSupplierProductJson[]> {
        let url_ = this.baseUrl + "/supplier/{supplierId}/products";
        if (supplierId === undefined || supplierId === null)
            throw new globalThis.Error("The parameter 'supplierId' must be defined.");
        url_ = url_.replace("{supplierId}", encodeURIComponent("" + supplierId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProductsAll(_response);
        });
    }

    protected processProductsAll(response: Response): Promise<ResponseSupplierProductJson[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ResponseSupplierProductJson.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseSupplierProductJson[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    productsPUT(supplierId: number, productId: number, body?: RequestUpdateSupplierProductJson | undefined, signal?: AbortSignal): Promise<ResponseSupplierProductJson> {
        let url_ = this.baseUrl + "/supplier/{supplierId}/products/{productId}";
        if (supplierId === undefined || supplierId === null)
            throw new globalThis.Error("The parameter 'supplierId' must be defined.");
        url_ = url_.replace("{supplierId}", encodeURIComponent("" + supplierId));
        if (productId === undefined || productId === null)
            throw new globalThis.Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProductsPUT(_response);
        });
    }

    protected processProductsPUT(response: Response): Promise<ResponseSupplierProductJson> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseSupplierProductJson.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ResponseErrorJson.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseSupplierProductJson>(null as any);
    }

    /**
     * @return No Content
     */
    productsDELETE(supplierId: number, productId: number, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/supplier/{supplierId}/products/{productId}";
        if (supplierId === undefined || supplierId === null)
            throw new globalThis.Error("The parameter 'supplierId' must be defined.");
        url_ = url_.replace("{supplierId}", encodeURIComponent("" + supplierId));
        if (productId === undefined || productId === null)
            throw new globalThis.Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProductsDELETE(_response);
        });
    }

    protected processProductsDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ResponseErrorJson.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    refreshToken(body?: RequestNewTokenJson | undefined, signal?: AbortSignal): Promise<ResponseTokensJson> {
        let url_ = this.baseUrl + "/token/refresh-token";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRefreshToken(_response);
        });
    }

    protected processRefreshToken(response: Response): Promise<ResponseTokensJson> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseTokensJson.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseTokensJson>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    userPOST(body?: RequestRegisterUserJson | undefined, signal?: AbortSignal): Promise<ResponseRegisterUserJson> {
        let url_ = this.baseUrl + "/user";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUserPOST(_response);
        });
    }

    protected processUserPOST(response: Response): Promise<ResponseRegisterUserJson> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ResponseRegisterUserJson.fromJS(resultData201);
            return result201;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseRegisterUserJson>(null as any);
    }

    /**
     * @return OK
     */
    userGET(signal?: AbortSignal): Promise<ResponseUserProfileJson> {
        let url_ = this.baseUrl + "/user";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUserGET(_response);
        });
    }

    protected processUserGET(response: Response): Promise<ResponseUserProfileJson> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseUserProfileJson.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseUserProfileJson>(null as any);
    }

    /**
     * @param body (optional) 
     * @return No Content
     */
    userPUT(body?: RequestUpdateUserJson | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/user";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUserPUT(_response);
        });
    }

    protected processUserPUT(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ResponseErrorJson.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return No Content
     */
    userDELETE(signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/user";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUserDELETE(_response);
        });
    }

    protected processUserDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    allUsers(signal?: AbortSignal): Promise<ResponseUserProfileJson> {
        let url_ = this.baseUrl + "/user/all-users";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAllUsers(_response);
        });
    }

    protected processAllUsers(response: Response): Promise<ResponseUserProfileJson> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseUserProfileJson.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseUserProfileJson>(null as any);
    }

    /**
     * @param body (optional) 
     * @return No Content
     */
    changePassword(body?: RequestChangePasswordJson | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/user/change-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processChangePassword(_response);
        });
    }

    protected processChangePassword(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ResponseErrorJson.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param search (optional) 
     * @return OK
     */
    warehouseGET(page?: number | undefined, pageSize?: number | undefined, search?: string | undefined, signal?: AbortSignal): Promise<ResponseWarehouseJsonPagedResponse> {
        let url_ = this.baseUrl + "/warehouse?";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (search === null)
            throw new globalThis.Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processWarehouseGET(_response);
        });
    }

    protected processWarehouseGET(response: Response): Promise<ResponseWarehouseJsonPagedResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseWarehouseJsonPagedResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseWarehouseJsonPagedResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    warehousePOST(body?: RequestRegisterWarehouseJson | undefined, signal?: AbortSignal): Promise<ResponseWarehouseJson> {
        let url_ = this.baseUrl + "/warehouse";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processWarehousePOST(_response);
        });
    }

    protected processWarehousePOST(response: Response): Promise<ResponseWarehouseJson> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ResponseWarehouseJson.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ResponseErrorJson.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseWarehouseJson>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    warehousePUT(id: number, body?: RequestUpdateWarehouseJson | undefined, signal?: AbortSignal): Promise<ResponseWarehouseJson> {
        let url_ = this.baseUrl + "/warehouse/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processWarehousePUT(_response);
        });
    }

    protected processWarehousePUT(response: Response): Promise<ResponseWarehouseJson> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseWarehouseJson.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ResponseErrorJson.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseWarehouseJson>(null as any);
    }

    /**
     * @return No Content
     */
    warehouseDELETE(id: number, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/warehouse/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processWarehouseDELETE(_response);
        });
    }

    protected processWarehouseDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ResponseErrorJson.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    warehouseGET2(id: number, signal?: AbortSignal): Promise<ResponseWarehouseJson> {
        let url_ = this.baseUrl + "/warehouse/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processWarehouseGET2(_response);
        });
    }

    protected processWarehouseGET2(response: Response): Promise<ResponseWarehouseJson> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseWarehouseJson.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseWarehouseJson>(null as any);
    }

    /**
     * @return OK
     */
    itemsAll(id: number, signal?: AbortSignal): Promise<ResponseWarehouseStockItemJson[]> {
        let url_ = this.baseUrl + "/warehouse/{id}/items";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processItemsAll(_response);
        });
    }

    protected processItemsAll(response: Response): Promise<ResponseWarehouseStockItemJson[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ResponseWarehouseStockItemJson.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseWarehouseStockItemJson[]>(null as any);
    }
}

export type MovementType = "INBOUND" | "OUTBOUND" | "ADJUST";

export type OrderStatus = "PENDING" | "PAID" | "SHIPPED" | "CANCELLED";

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

export class ReplenishmentPoItemJson implements IReplenishmentPoItemJson {
    productId?: number;
    quantity?: number;
    unitPrice?: number;

    constructor(data?: IReplenishmentPoItemJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.quantity = _data["quantity"];
            this.unitPrice = _data["unitPrice"];
        }
    }

    static fromJS(data: any): ReplenishmentPoItemJson {
        data = typeof data === 'object' ? data : {};
        let result = new ReplenishmentPoItemJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["quantity"] = this.quantity;
        data["unitPrice"] = this.unitPrice;
        return data;
    }
}

export interface IReplenishmentPoItemJson {
    productId?: number;
    quantity?: number;
    unitPrice?: number;
}

export class RequestAdminCreateUserJson implements IRequestAdminCreateUserJson {
    name?: string | undefined;
    email?: string | undefined;
    password?: string | undefined;
    role?: string | undefined;

    constructor(data?: IRequestAdminCreateUserJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.email = _data["email"];
            this.password = _data["password"];
            this.role = _data["role"];
        }
    }

    static fromJS(data: any): RequestAdminCreateUserJson {
        data = typeof data === 'object' ? data : {};
        let result = new RequestAdminCreateUserJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["email"] = this.email;
        data["password"] = this.password;
        data["role"] = this.role;
        return data;
    }
}

export interface IRequestAdminCreateUserJson {
    name?: string | undefined;
    email?: string | undefined;
    password?: string | undefined;
    role?: string | undefined;
}

export class RequestAdminUpdateUserJson implements IRequestAdminUpdateUserJson {
    name?: string | undefined;
    email?: string | undefined;
    newPassword?: string | undefined;
    role?: string | undefined;
    active?: boolean;

    constructor(data?: IRequestAdminUpdateUserJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.email = _data["email"];
            this.newPassword = _data["newPassword"];
            this.role = _data["role"];
            this.active = _data["active"];
        }
    }

    static fromJS(data: any): RequestAdminUpdateUserJson {
        data = typeof data === 'object' ? data : {};
        let result = new RequestAdminUpdateUserJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["email"] = this.email;
        data["newPassword"] = this.newPassword;
        data["role"] = this.role;
        data["active"] = this.active;
        return data;
    }
}

export interface IRequestAdminUpdateUserJson {
    name?: string | undefined;
    email?: string | undefined;
    newPassword?: string | undefined;
    role?: string | undefined;
    active?: boolean;
}

export class RequestChangePasswordJson implements IRequestChangePasswordJson {
    password?: string | undefined;
    newPassword?: string | undefined;

    constructor(data?: IRequestChangePasswordJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.password = _data["password"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): RequestChangePasswordJson {
        data = typeof data === 'object' ? data : {};
        let result = new RequestChangePasswordJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["password"] = this.password;
        data["newPassword"] = this.newPassword;
        return data;
    }
}

export interface IRequestChangePasswordJson {
    password?: string | undefined;
    newPassword?: string | undefined;
}

export class RequestContactJson implements IRequestContactJson {
    name?: string | undefined;
    email?: string | undefined;
    subject?: string | undefined;
    message?: string | undefined;

    constructor(data?: IRequestContactJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.email = _data["email"];
            this.subject = _data["subject"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): RequestContactJson {
        data = typeof data === 'object' ? data : {};
        let result = new RequestContactJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["email"] = this.email;
        data["subject"] = this.subject;
        data["message"] = this.message;
        return data;
    }
}

export interface IRequestContactJson {
    name?: string | undefined;
    email?: string | undefined;
    subject?: string | undefined;
    message?: string | undefined;
}

export class RequestCreateOrderItemJson implements IRequestCreateOrderItemJson {
    productId?: number;
    quantity?: number;
    price?: number;

    constructor(data?: IRequestCreateOrderItemJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.quantity = _data["quantity"];
            this.price = _data["price"];
        }
    }

    static fromJS(data: any): RequestCreateOrderItemJson {
        data = typeof data === 'object' ? data : {};
        let result = new RequestCreateOrderItemJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["quantity"] = this.quantity;
        data["price"] = this.price;
        return data;
    }
}

export interface IRequestCreateOrderItemJson {
    productId?: number;
    quantity?: number;
    price?: number;
}

export class RequestCreateOrderJson implements IRequestCreateOrderJson {
    customerName?: string | undefined;
    items?: RequestCreateOrderItemJson[] | undefined;

    constructor(data?: IRequestCreateOrderJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customerName = _data["customerName"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(RequestCreateOrderItemJson.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RequestCreateOrderJson {
        data = typeof data === 'object' ? data : {};
        let result = new RequestCreateOrderJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerName"] = this.customerName;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IRequestCreateOrderJson {
    customerName?: string | undefined;
    items?: RequestCreateOrderItemJson[] | undefined;
}

export class RequestCreatePurchaseOrderItemJson implements IRequestCreatePurchaseOrderItemJson {
    productId?: number;
    quantity?: number;
    unitPrice?: number;

    constructor(data?: IRequestCreatePurchaseOrderItemJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.quantity = _data["quantity"];
            this.unitPrice = _data["unitPrice"];
        }
    }

    static fromJS(data: any): RequestCreatePurchaseOrderItemJson {
        data = typeof data === 'object' ? data : {};
        let result = new RequestCreatePurchaseOrderItemJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["quantity"] = this.quantity;
        data["unitPrice"] = this.unitPrice;
        return data;
    }
}

export interface IRequestCreatePurchaseOrderItemJson {
    productId?: number;
    quantity?: number;
    unitPrice?: number;
}

export class RequestCreatePurchaseOrderJson implements IRequestCreatePurchaseOrderJson {
    number?: string | undefined;
    supplierId?: number;
    warehouseId?: number;
    items?: RequestCreatePurchaseOrderItemJson[] | undefined;

    constructor(data?: IRequestCreatePurchaseOrderJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.number = _data["number"];
            this.supplierId = _data["supplierId"];
            this.warehouseId = _data["warehouseId"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(RequestCreatePurchaseOrderItemJson.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RequestCreatePurchaseOrderJson {
        data = typeof data === 'object' ? data : {};
        let result = new RequestCreatePurchaseOrderJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["number"] = this.number;
        data["supplierId"] = this.supplierId;
        data["warehouseId"] = this.warehouseId;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IRequestCreatePurchaseOrderJson {
    number?: string | undefined;
    supplierId?: number;
    warehouseId?: number;
    items?: RequestCreatePurchaseOrderItemJson[] | undefined;
}

export class RequestGeneratePoFromReplenishmentJson implements IRequestGeneratePoFromReplenishmentJson {
    supplierId?: number;
    warehouseId?: number;
    notes?: string | undefined;
    items?: ReplenishmentPoItemJson[] | undefined;

    constructor(data?: IRequestGeneratePoFromReplenishmentJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.supplierId = _data["supplierId"];
            this.warehouseId = _data["warehouseId"];
            this.notes = _data["notes"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ReplenishmentPoItemJson.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RequestGeneratePoFromReplenishmentJson {
        data = typeof data === 'object' ? data : {};
        let result = new RequestGeneratePoFromReplenishmentJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["supplierId"] = this.supplierId;
        data["warehouseId"] = this.warehouseId;
        data["notes"] = this.notes;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IRequestGeneratePoFromReplenishmentJson {
    supplierId?: number;
    warehouseId?: number;
    notes?: string | undefined;
    items?: ReplenishmentPoItemJson[] | undefined;
}

export class RequestLoginJson implements IRequestLoginJson {
    email?: string | undefined;
    password?: string | undefined;

    constructor(data?: IRequestLoginJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): RequestLoginJson {
        data = typeof data === 'object' ? data : {};
        let result = new RequestLoginJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export interface IRequestLoginJson {
    email?: string | undefined;
    password?: string | undefined;
}

export class RequestNewTokenJson implements IRequestNewTokenJson {
    refreshToken?: string | undefined;
    tokenId?: string | undefined;

    constructor(data?: IRequestNewTokenJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.refreshToken = _data["refreshToken"];
            this.tokenId = _data["tokenId"];
        }
    }

    static fromJS(data: any): RequestNewTokenJson {
        data = typeof data === 'object' ? data : {};
        let result = new RequestNewTokenJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["refreshToken"] = this.refreshToken;
        data["tokenId"] = this.tokenId;
        return data;
    }
}

export interface IRequestNewTokenJson {
    refreshToken?: string | undefined;
    tokenId?: string | undefined;
}

export class RequestRegisterMovementJson implements IRequestRegisterMovementJson {
    reference?: string | undefined;
    productId?: number;
    warehouseId?: number;
    type?: MovementType;
    quantity?: number;

    constructor(data?: IRequestRegisterMovementJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reference = _data["reference"];
            this.productId = _data["productId"];
            this.warehouseId = _data["warehouseId"];
            this.type = _data["type"];
            this.quantity = _data["quantity"];
        }
    }

    static fromJS(data: any): RequestRegisterMovementJson {
        data = typeof data === 'object' ? data : {};
        let result = new RequestRegisterMovementJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reference"] = this.reference;
        data["productId"] = this.productId;
        data["warehouseId"] = this.warehouseId;
        data["type"] = this.type;
        data["quantity"] = this.quantity;
        return data;
    }
}

export interface IRequestRegisterMovementJson {
    reference?: string | undefined;
    productId?: number;
    warehouseId?: number;
    type?: MovementType;
    quantity?: number;
}

export class RequestRegisterOrganizationJson implements IRequestRegisterOrganizationJson {
    name?: string | undefined;
    adminName?: string | undefined;
    adminEmail?: string | undefined;
    adminPassword?: string | undefined;

    constructor(data?: IRequestRegisterOrganizationJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.adminName = _data["adminName"];
            this.adminEmail = _data["adminEmail"];
            this.adminPassword = _data["adminPassword"];
        }
    }

    static fromJS(data: any): RequestRegisterOrganizationJson {
        data = typeof data === 'object' ? data : {};
        let result = new RequestRegisterOrganizationJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["adminName"] = this.adminName;
        data["adminEmail"] = this.adminEmail;
        data["adminPassword"] = this.adminPassword;
        return data;
    }
}

export interface IRequestRegisterOrganizationJson {
    name?: string | undefined;
    adminName?: string | undefined;
    adminEmail?: string | undefined;
    adminPassword?: string | undefined;
}

export class RequestRegisterProductJson implements IRequestRegisterProductJson {
    sku?: string | undefined;
    name?: string | undefined;
    category?: string | undefined;
    uoM?: string | undefined;
    price?: number;
    stock?: number;
    reorderPoint?: number;

    constructor(data?: IRequestRegisterProductJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sku = _data["sku"];
            this.name = _data["name"];
            this.category = _data["category"];
            this.uoM = _data["uoM"];
            this.price = _data["price"];
            this.stock = _data["stock"];
            this.reorderPoint = _data["reorderPoint"];
        }
    }

    static fromJS(data: any): RequestRegisterProductJson {
        data = typeof data === 'object' ? data : {};
        let result = new RequestRegisterProductJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sku"] = this.sku;
        data["name"] = this.name;
        data["category"] = this.category;
        data["uoM"] = this.uoM;
        data["price"] = this.price;
        data["stock"] = this.stock;
        data["reorderPoint"] = this.reorderPoint;
        return data;
    }
}

export interface IRequestRegisterProductJson {
    sku?: string | undefined;
    name?: string | undefined;
    category?: string | undefined;
    uoM?: string | undefined;
    price?: number;
    stock?: number;
    reorderPoint?: number;
}

export class RequestRegisterStockItemJson implements IRequestRegisterStockItemJson {
    productId?: number;
    warehouseId?: number;
    quantity?: number;

    constructor(data?: IRequestRegisterStockItemJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.warehouseId = _data["warehouseId"];
            this.quantity = _data["quantity"];
        }
    }

    static fromJS(data: any): RequestRegisterStockItemJson {
        data = typeof data === 'object' ? data : {};
        let result = new RequestRegisterStockItemJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["warehouseId"] = this.warehouseId;
        data["quantity"] = this.quantity;
        return data;
    }
}

export interface IRequestRegisterStockItemJson {
    productId?: number;
    warehouseId?: number;
    quantity?: number;
}

export class RequestRegisterSupplierJson implements IRequestRegisterSupplierJson {
    name?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
    contact?: string | undefined;
    address?: string | undefined;

    constructor(data?: IRequestRegisterSupplierJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.contact = _data["contact"];
            this.address = _data["address"];
        }
    }

    static fromJS(data: any): RequestRegisterSupplierJson {
        data = typeof data === 'object' ? data : {};
        let result = new RequestRegisterSupplierJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["contact"] = this.contact;
        data["address"] = this.address;
        return data;
    }
}

export interface IRequestRegisterSupplierJson {
    name?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
    contact?: string | undefined;
    address?: string | undefined;
}

export class RequestRegisterSupplierProductJson implements IRequestRegisterSupplierProductJson {
    supplierId?: number;
    productId?: number;
    unitPrice?: number | undefined;
    supplierSKU?: string | undefined;

    constructor(data?: IRequestRegisterSupplierProductJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.supplierId = _data["supplierId"];
            this.productId = _data["productId"];
            this.unitPrice = _data["unitPrice"];
            this.supplierSKU = _data["supplierSKU"];
        }
    }

    static fromJS(data: any): RequestRegisterSupplierProductJson {
        data = typeof data === 'object' ? data : {};
        let result = new RequestRegisterSupplierProductJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["supplierId"] = this.supplierId;
        data["productId"] = this.productId;
        data["unitPrice"] = this.unitPrice;
        data["supplierSKU"] = this.supplierSKU;
        return data;
    }
}

export interface IRequestRegisterSupplierProductJson {
    supplierId?: number;
    productId?: number;
    unitPrice?: number | undefined;
    supplierSKU?: string | undefined;
}

export class RequestRegisterUserJson implements IRequestRegisterUserJson {
    name?: string | undefined;
    email?: string | undefined;
    password?: string | undefined;
    organizationId?: number;
    role?: string | undefined;

    constructor(data?: IRequestRegisterUserJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.email = _data["email"];
            this.password = _data["password"];
            this.organizationId = _data["organizationId"];
            this.role = _data["role"];
        }
    }

    static fromJS(data: any): RequestRegisterUserJson {
        data = typeof data === 'object' ? data : {};
        let result = new RequestRegisterUserJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["email"] = this.email;
        data["password"] = this.password;
        data["organizationId"] = this.organizationId;
        data["role"] = this.role;
        return data;
    }
}

export interface IRequestRegisterUserJson {
    name?: string | undefined;
    email?: string | undefined;
    password?: string | undefined;
    organizationId?: number;
    role?: string | undefined;
}

export class RequestRegisterWarehouseJson implements IRequestRegisterWarehouseJson {
    name?: string | undefined;
    location?: string | undefined;
    capacity?: number;
    items?: number;

    constructor(data?: IRequestRegisterWarehouseJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.location = _data["location"];
            this.capacity = _data["capacity"];
            this.items = _data["items"];
        }
    }

    static fromJS(data: any): RequestRegisterWarehouseJson {
        data = typeof data === 'object' ? data : {};
        let result = new RequestRegisterWarehouseJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["location"] = this.location;
        data["capacity"] = this.capacity;
        data["items"] = this.items;
        return data;
    }
}

export interface IRequestRegisterWarehouseJson {
    name?: string | undefined;
    location?: string | undefined;
    capacity?: number;
    items?: number;
}

export class RequestResetYourPasswordJson implements IRequestResetYourPasswordJson {
    email?: string | undefined;
    code?: string | undefined;
    password?: string | undefined;

    constructor(data?: IRequestResetYourPasswordJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.code = _data["code"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): RequestResetYourPasswordJson {
        data = typeof data === 'object' ? data : {};
        let result = new RequestResetYourPasswordJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["code"] = this.code;
        data["password"] = this.password;
        return data;
    }
}

export interface IRequestResetYourPasswordJson {
    email?: string | undefined;
    code?: string | undefined;
    password?: string | undefined;
}

export class RequestUpdateOrderStatusJson implements IRequestUpdateOrderStatusJson {
    status?: OrderStatus;

    constructor(data?: IRequestUpdateOrderStatusJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): RequestUpdateOrderStatusJson {
        data = typeof data === 'object' ? data : {};
        let result = new RequestUpdateOrderStatusJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        return data;
    }
}

export interface IRequestUpdateOrderStatusJson {
    status?: OrderStatus;
}

export class RequestUpdatePurchaseOrderItemJson implements IRequestUpdatePurchaseOrderItemJson {
    productId?: number;
    quantity?: number;
    unitPrice?: number;

    constructor(data?: IRequestUpdatePurchaseOrderItemJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.quantity = _data["quantity"];
            this.unitPrice = _data["unitPrice"];
        }
    }

    static fromJS(data: any): RequestUpdatePurchaseOrderItemJson {
        data = typeof data === 'object' ? data : {};
        let result = new RequestUpdatePurchaseOrderItemJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["quantity"] = this.quantity;
        data["unitPrice"] = this.unitPrice;
        return data;
    }
}

export interface IRequestUpdatePurchaseOrderItemJson {
    productId?: number;
    quantity?: number;
    unitPrice?: number;
}

export class RequestUpdatePurchaseOrderItemsJson implements IRequestUpdatePurchaseOrderItemsJson {
    items?: RequestUpdatePurchaseOrderItemJson[] | undefined;

    constructor(data?: IRequestUpdatePurchaseOrderItemsJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(RequestUpdatePurchaseOrderItemJson.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RequestUpdatePurchaseOrderItemsJson {
        data = typeof data === 'object' ? data : {};
        let result = new RequestUpdatePurchaseOrderItemsJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IRequestUpdatePurchaseOrderItemsJson {
    items?: RequestUpdatePurchaseOrderItemJson[] | undefined;
}

export class RequestUpdatePurchaseOrderStatusJson implements IRequestUpdatePurchaseOrderStatusJson {
    status?: string | undefined;

    constructor(data?: IRequestUpdatePurchaseOrderStatusJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): RequestUpdatePurchaseOrderStatusJson {
        data = typeof data === 'object' ? data : {};
        let result = new RequestUpdatePurchaseOrderStatusJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        return data;
    }
}

export interface IRequestUpdatePurchaseOrderStatusJson {
    status?: string | undefined;
}

export class RequestUpdateSupplierJson implements IRequestUpdateSupplierJson {
    name?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
    contact?: string | undefined;
    address?: string | undefined;

    constructor(data?: IRequestUpdateSupplierJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.contact = _data["contact"];
            this.address = _data["address"];
        }
    }

    static fromJS(data: any): RequestUpdateSupplierJson {
        data = typeof data === 'object' ? data : {};
        let result = new RequestUpdateSupplierJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["contact"] = this.contact;
        data["address"] = this.address;
        return data;
    }
}

export interface IRequestUpdateSupplierJson {
    name?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
    contact?: string | undefined;
    address?: string | undefined;
}

export class RequestUpdateSupplierProductJson implements IRequestUpdateSupplierProductJson {
    supplierId?: number;
    productId?: number;
    unitPrice?: number;
    active?: boolean;

    constructor(data?: IRequestUpdateSupplierProductJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.supplierId = _data["supplierId"];
            this.productId = _data["productId"];
            this.unitPrice = _data["unitPrice"];
            this.active = _data["active"];
        }
    }

    static fromJS(data: any): RequestUpdateSupplierProductJson {
        data = typeof data === 'object' ? data : {};
        let result = new RequestUpdateSupplierProductJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["supplierId"] = this.supplierId;
        data["productId"] = this.productId;
        data["unitPrice"] = this.unitPrice;
        data["active"] = this.active;
        return data;
    }
}

export interface IRequestUpdateSupplierProductJson {
    supplierId?: number;
    productId?: number;
    unitPrice?: number;
    active?: boolean;
}

export class RequestUpdateUserJson implements IRequestUpdateUserJson {
    name?: string | undefined;
    email?: string | undefined;

    constructor(data?: IRequestUpdateUserJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): RequestUpdateUserJson {
        data = typeof data === 'object' ? data : {};
        let result = new RequestUpdateUserJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["email"] = this.email;
        return data;
    }
}

export interface IRequestUpdateUserJson {
    name?: string | undefined;
    email?: string | undefined;
}

export class RequestUpdateWarehouseJson implements IRequestUpdateWarehouseJson {
    name?: string | undefined;
    location?: string | undefined;
    capacity?: number;
    items?: number;

    constructor(data?: IRequestUpdateWarehouseJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.location = _data["location"];
            this.capacity = _data["capacity"];
            this.items = _data["items"];
        }
    }

    static fromJS(data: any): RequestUpdateWarehouseJson {
        data = typeof data === 'object' ? data : {};
        let result = new RequestUpdateWarehouseJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["location"] = this.location;
        data["capacity"] = this.capacity;
        data["items"] = this.items;
        return data;
    }
}

export interface IRequestUpdateWarehouseJson {
    name?: string | undefined;
    location?: string | undefined;
    capacity?: number;
    items?: number;
}

export class RequestValidateResetCodeJson implements IRequestValidateResetCodeJson {
    email?: string | undefined;
    code?: string | undefined;

    constructor(data?: IRequestValidateResetCodeJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): RequestValidateResetCodeJson {
        data = typeof data === 'object' ? data : {};
        let result = new RequestValidateResetCodeJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["code"] = this.code;
        return data;
    }
}

export interface IRequestValidateResetCodeJson {
    email?: string | undefined;
    code?: string | undefined;
}

export class ResponseAdminCreateUserJson implements IResponseAdminCreateUserJson {
    id?: number;
    name?: string | undefined;
    email?: string | undefined;
    role?: string | undefined;
    active?: boolean;

    constructor(data?: IResponseAdminCreateUserJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.email = _data["email"];
            this.role = _data["role"];
            this.active = _data["active"];
        }
    }

    static fromJS(data: any): ResponseAdminCreateUserJson {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseAdminCreateUserJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["email"] = this.email;
        data["role"] = this.role;
        data["active"] = this.active;
        return data;
    }
}

export interface IResponseAdminCreateUserJson {
    id?: number;
    name?: string | undefined;
    email?: string | undefined;
    role?: string | undefined;
    active?: boolean;
}

export class ResponseAuditLogJson implements IResponseAuditLogJson {
    user?: string | undefined;
    action?: string | undefined;
    type?: string | undefined;
    date?: Date;

    constructor(data?: IResponseAuditLogJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.user = _data["user"];
            this.action = _data["action"];
            this.type = _data["type"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): ResponseAuditLogJson {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseAuditLogJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user;
        data["action"] = this.action;
        data["type"] = this.type;
        data["date"] = this.date ? this.date.toISOString() : undefined as any;
        return data;
    }
}

export interface IResponseAuditLogJson {
    user?: string | undefined;
    action?: string | undefined;
    type?: string | undefined;
    date?: Date;
}

export class ResponseErrorJson implements IResponseErrorJson {
    errors?: string[] | undefined;
    tokenExpired?: boolean;

    constructor(data?: IResponseErrorJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.tokenExpired = _data["tokenExpired"];
        }
    }

    static fromJS(data: any): ResponseErrorJson {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseErrorJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["tokenExpired"] = this.tokenExpired;
        return data;
    }
}

export interface IResponseErrorJson {
    errors?: string[] | undefined;
    tokenExpired?: boolean;
}

export class ResponseMovementJson implements IResponseMovementJson {
    id?: number;
    reference?: string | undefined;
    product?: string | undefined;
    warehouse?: string | undefined;
    type?: string | undefined;
    quantity?: number;
    createdAt?: Date;
    createdByName?: string | undefined;

    constructor(data?: IResponseMovementJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.reference = _data["reference"];
            this.product = _data["product"];
            this.warehouse = _data["warehouse"];
            this.type = _data["type"];
            this.quantity = _data["quantity"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.createdByName = _data["createdByName"];
        }
    }

    static fromJS(data: any): ResponseMovementJson {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseMovementJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["reference"] = this.reference;
        data["product"] = this.product;
        data["warehouse"] = this.warehouse;
        data["type"] = this.type;
        data["quantity"] = this.quantity;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["createdByName"] = this.createdByName;
        return data;
    }
}

export interface IResponseMovementJson {
    id?: number;
    reference?: string | undefined;
    product?: string | undefined;
    warehouse?: string | undefined;
    type?: string | undefined;
    quantity?: number;
    createdAt?: Date;
    createdByName?: string | undefined;
}

export class ResponseMovementJsonPagedResponse implements IResponseMovementJsonPagedResponse {
    items?: ResponseMovementJson[] | undefined;
    total?: number;
    page?: number;
    pageSize?: number;

    constructor(data?: IResponseMovementJsonPagedResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ResponseMovementJson.fromJS(item));
            }
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
        }
    }

    static fromJS(data: any): ResponseMovementJsonPagedResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseMovementJsonPagedResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        return data;
    }
}

export interface IResponseMovementJsonPagedResponse {
    items?: ResponseMovementJson[] | undefined;
    total?: number;
    page?: number;
    pageSize?: number;
}

export class ResponseNotificationJson implements IResponseNotificationJson {
    id?: number;
    message?: string | undefined;
    isRead?: boolean;
    createdAt?: Date;

    constructor(data?: IResponseNotificationJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.message = _data["message"];
            this.isRead = _data["isRead"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): ResponseNotificationJson {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseNotificationJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["message"] = this.message;
        data["isRead"] = this.isRead;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        return data;
    }
}

export interface IResponseNotificationJson {
    id?: number;
    message?: string | undefined;
    isRead?: boolean;
    createdAt?: Date;
}

export class ResponseOrderItemJson implements IResponseOrderItemJson {
    productId?: number;
    productName?: string | undefined;
    quantity?: number;
    price?: number;

    constructor(data?: IResponseOrderItemJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.productName = _data["productName"];
            this.quantity = _data["quantity"];
            this.price = _data["price"];
        }
    }

    static fromJS(data: any): ResponseOrderItemJson {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseOrderItemJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["productName"] = this.productName;
        data["quantity"] = this.quantity;
        data["price"] = this.price;
        return data;
    }
}

export interface IResponseOrderItemJson {
    productId?: number;
    productName?: string | undefined;
    quantity?: number;
    price?: number;
}

export class ResponseOrderJson implements IResponseOrderJson {
    id?: number;
    orderNumber?: string | undefined;
    customerName?: string | undefined;
    total?: number;
    status?: OrderStatus;
    createdOn?: Date;
    items?: ResponseOrderItemJson[] | undefined;

    constructor(data?: IResponseOrderJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.orderNumber = _data["orderNumber"];
            this.customerName = _data["customerName"];
            this.total = _data["total"];
            this.status = _data["status"];
            this.createdOn = _data["createdOn"] ? new Date(_data["createdOn"].toString()) : undefined as any;
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ResponseOrderItemJson.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResponseOrderJson {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseOrderJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["orderNumber"] = this.orderNumber;
        data["customerName"] = this.customerName;
        data["total"] = this.total;
        data["status"] = this.status;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : undefined as any;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IResponseOrderJson {
    id?: number;
    orderNumber?: string | undefined;
    customerName?: string | undefined;
    total?: number;
    status?: OrderStatus;
    createdOn?: Date;
    items?: ResponseOrderItemJson[] | undefined;
}

export class ResponseOverviewJson implements IResponseOverviewJson {
    totalProducts?: number;
    totalWarehouses?: number;
    totalMovements?: number;
    totalStockItems?: number;
    totalInventoryQuantity?: number;

    constructor(data?: IResponseOverviewJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalProducts = _data["totalProducts"];
            this.totalWarehouses = _data["totalWarehouses"];
            this.totalMovements = _data["totalMovements"];
            this.totalStockItems = _data["totalStockItems"];
            this.totalInventoryQuantity = _data["totalInventoryQuantity"];
        }
    }

    static fromJS(data: any): ResponseOverviewJson {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseOverviewJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalProducts"] = this.totalProducts;
        data["totalWarehouses"] = this.totalWarehouses;
        data["totalMovements"] = this.totalMovements;
        data["totalStockItems"] = this.totalStockItems;
        data["totalInventoryQuantity"] = this.totalInventoryQuantity;
        return data;
    }
}

export interface IResponseOverviewJson {
    totalProducts?: number;
    totalWarehouses?: number;
    totalMovements?: number;
    totalStockItems?: number;
    totalInventoryQuantity?: number;
}

export class ResponseProductJson implements IResponseProductJson {
    id?: number;
    sku?: string | undefined;
    name?: string | undefined;
    category?: string | undefined;
    uoM?: string | undefined;
    price?: number;
    totalStock?: number;
    reorderPoint?: number;
    updatedAt?: Date;
    active?: boolean;
    createdByUserId?: number;
    createdByName?: string | undefined;
    stockItems?: ResponseStockItemJson[] | undefined;

    constructor(data?: IResponseProductJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.sku = _data["sku"];
            this.name = _data["name"];
            this.category = _data["category"];
            this.uoM = _data["uoM"];
            this.price = _data["price"];
            this.totalStock = _data["totalStock"];
            this.reorderPoint = _data["reorderPoint"];
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : undefined as any;
            this.active = _data["active"];
            this.createdByUserId = _data["createdByUserId"];
            this.createdByName = _data["createdByName"];
            if (Array.isArray(_data["stockItems"])) {
                this.stockItems = [] as any;
                for (let item of _data["stockItems"])
                    this.stockItems!.push(ResponseStockItemJson.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResponseProductJson {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseProductJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sku"] = this.sku;
        data["name"] = this.name;
        data["category"] = this.category;
        data["uoM"] = this.uoM;
        data["price"] = this.price;
        data["totalStock"] = this.totalStock;
        data["reorderPoint"] = this.reorderPoint;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        data["active"] = this.active;
        data["createdByUserId"] = this.createdByUserId;
        data["createdByName"] = this.createdByName;
        if (Array.isArray(this.stockItems)) {
            data["stockItems"] = [];
            for (let item of this.stockItems)
                data["stockItems"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IResponseProductJson {
    id?: number;
    sku?: string | undefined;
    name?: string | undefined;
    category?: string | undefined;
    uoM?: string | undefined;
    price?: number;
    totalStock?: number;
    reorderPoint?: number;
    updatedAt?: Date;
    active?: boolean;
    createdByUserId?: number;
    createdByName?: string | undefined;
    stockItems?: ResponseStockItemJson[] | undefined;
}

export class ResponseProductJsonPagedResponse implements IResponseProductJsonPagedResponse {
    items?: ResponseProductJson[] | undefined;
    total?: number;
    page?: number;
    pageSize?: number;

    constructor(data?: IResponseProductJsonPagedResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ResponseProductJson.fromJS(item));
            }
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
        }
    }

    static fromJS(data: any): ResponseProductJsonPagedResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseProductJsonPagedResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        return data;
    }
}

export interface IResponseProductJsonPagedResponse {
    items?: ResponseProductJson[] | undefined;
    total?: number;
    page?: number;
    pageSize?: number;
}

export class ResponsePurchaseOrderItemJson implements IResponsePurchaseOrderItemJson {
    productName?: string | undefined;
    quantity?: number;
    unitPrice?: number;

    constructor(data?: IResponsePurchaseOrderItemJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productName = _data["productName"];
            this.quantity = _data["quantity"];
            this.unitPrice = _data["unitPrice"];
        }
    }

    static fromJS(data: any): ResponsePurchaseOrderItemJson {
        data = typeof data === 'object' ? data : {};
        let result = new ResponsePurchaseOrderItemJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productName"] = this.productName;
        data["quantity"] = this.quantity;
        data["unitPrice"] = this.unitPrice;
        return data;
    }
}

export interface IResponsePurchaseOrderItemJson {
    productName?: string | undefined;
    quantity?: number;
    unitPrice?: number;
}

export class ResponsePurchaseOrderJson implements IResponsePurchaseOrderJson {
    id?: number;
    number?: string | undefined;
    supplierName?: string | undefined;
    status?: string | undefined;
    warehouseId?: number;
    warehouseName?: string | undefined;
    createdAt?: Date;
    createdByName?: string | undefined;
    items?: ResponsePurchaseOrderItemJson[] | undefined;

    constructor(data?: IResponsePurchaseOrderJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.number = _data["number"];
            this.supplierName = _data["supplierName"];
            this.status = _data["status"];
            this.warehouseId = _data["warehouseId"];
            this.warehouseName = _data["warehouseName"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.createdByName = _data["createdByName"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ResponsePurchaseOrderItemJson.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResponsePurchaseOrderJson {
        data = typeof data === 'object' ? data : {};
        let result = new ResponsePurchaseOrderJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["number"] = this.number;
        data["supplierName"] = this.supplierName;
        data["status"] = this.status;
        data["warehouseId"] = this.warehouseId;
        data["warehouseName"] = this.warehouseName;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["createdByName"] = this.createdByName;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IResponsePurchaseOrderJson {
    id?: number;
    number?: string | undefined;
    supplierName?: string | undefined;
    status?: string | undefined;
    warehouseId?: number;
    warehouseName?: string | undefined;
    createdAt?: Date;
    createdByName?: string | undefined;
    items?: ResponsePurchaseOrderItemJson[] | undefined;
}

export class ResponsePurchaseOrderJsonPagedResponse implements IResponsePurchaseOrderJsonPagedResponse {
    items?: ResponsePurchaseOrderJson[] | undefined;
    total?: number;
    page?: number;
    pageSize?: number;

    constructor(data?: IResponsePurchaseOrderJsonPagedResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ResponsePurchaseOrderJson.fromJS(item));
            }
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
        }
    }

    static fromJS(data: any): ResponsePurchaseOrderJsonPagedResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ResponsePurchaseOrderJsonPagedResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        return data;
    }
}

export interface IResponsePurchaseOrderJsonPagedResponse {
    items?: ResponsePurchaseOrderJson[] | undefined;
    total?: number;
    page?: number;
    pageSize?: number;
}

export class ResponseRecentPurchaseOrderJson implements IResponseRecentPurchaseOrderJson {
    id?: number;
    supplierName?: string | undefined;
    status?: string | undefined;
    total?: number;
    createdAt?: Date;

    constructor(data?: IResponseRecentPurchaseOrderJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.supplierName = _data["supplierName"];
            this.status = _data["status"];
            this.total = _data["total"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): ResponseRecentPurchaseOrderJson {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseRecentPurchaseOrderJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["supplierName"] = this.supplierName;
        data["status"] = this.status;
        data["total"] = this.total;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        return data;
    }
}

export interface IResponseRecentPurchaseOrderJson {
    id?: number;
    supplierName?: string | undefined;
    status?: string | undefined;
    total?: number;
    createdAt?: Date;
}

export class ResponseRegisterOrganizationJson implements IResponseRegisterOrganizationJson {
    organizationId?: number;
    organizationName?: string | undefined;
    adminUser?: ResponseRegisterUserJson;

    constructor(data?: IResponseRegisterOrganizationJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.organizationId = _data["organizationId"];
            this.organizationName = _data["organizationName"];
            this.adminUser = _data["adminUser"] ? ResponseRegisterUserJson.fromJS(_data["adminUser"]) : undefined as any;
        }
    }

    static fromJS(data: any): ResponseRegisterOrganizationJson {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseRegisterOrganizationJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationId"] = this.organizationId;
        data["organizationName"] = this.organizationName;
        data["adminUser"] = this.adminUser ? this.adminUser.toJSON() : undefined as any;
        return data;
    }
}

export interface IResponseRegisterOrganizationJson {
    organizationId?: number;
    organizationName?: string | undefined;
    adminUser?: ResponseRegisterUserJson;
}

export class ResponseRegisterUserJson implements IResponseRegisterUserJson {
    name?: string | undefined;
    email?: string | undefined;
    role?: string | undefined;
    organizationName?: string | undefined;
    organizationId?: number;
    tokens?: ResponseTokensJson;

    constructor(data?: IResponseRegisterUserJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.email = _data["email"];
            this.role = _data["role"];
            this.organizationName = _data["organizationName"];
            this.organizationId = _data["organizationId"];
            this.tokens = _data["tokens"] ? ResponseTokensJson.fromJS(_data["tokens"]) : undefined as any;
        }
    }

    static fromJS(data: any): ResponseRegisterUserJson {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseRegisterUserJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["email"] = this.email;
        data["role"] = this.role;
        data["organizationName"] = this.organizationName;
        data["organizationId"] = this.organizationId;
        data["tokens"] = this.tokens ? this.tokens.toJSON() : undefined as any;
        return data;
    }
}

export interface IResponseRegisterUserJson {
    name?: string | undefined;
    email?: string | undefined;
    role?: string | undefined;
    organizationName?: string | undefined;
    organizationId?: number;
    tokens?: ResponseTokensJson;
}

export class ResponseReplenishmentItemJson implements IResponseReplenishmentItemJson {
    productId?: number;
    sku?: string | undefined;
    name?: string | undefined;
    category?: string | undefined;
    uom?: string | undefined;
    currentStock?: number;
    reorderPoint?: number;
    dailyConsumption?: number;
    leadTimeDays?: number;
    suggestedQty?: number;
    isCritical?: boolean;
    unitPrice?: number;
    warehouseId?: number;
    warehouseName?: string | undefined;

    constructor(data?: IResponseReplenishmentItemJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.sku = _data["sku"];
            this.name = _data["name"];
            this.category = _data["category"];
            this.uom = _data["uom"];
            this.currentStock = _data["currentStock"];
            this.reorderPoint = _data["reorderPoint"];
            this.dailyConsumption = _data["dailyConsumption"];
            this.leadTimeDays = _data["leadTimeDays"];
            this.suggestedQty = _data["suggestedQty"];
            this.isCritical = _data["isCritical"];
            this.unitPrice = _data["unitPrice"];
            this.warehouseId = _data["warehouseId"];
            this.warehouseName = _data["warehouseName"];
        }
    }

    static fromJS(data: any): ResponseReplenishmentItemJson {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseReplenishmentItemJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["sku"] = this.sku;
        data["name"] = this.name;
        data["category"] = this.category;
        data["uom"] = this.uom;
        data["currentStock"] = this.currentStock;
        data["reorderPoint"] = this.reorderPoint;
        data["dailyConsumption"] = this.dailyConsumption;
        data["leadTimeDays"] = this.leadTimeDays;
        data["suggestedQty"] = this.suggestedQty;
        data["isCritical"] = this.isCritical;
        data["unitPrice"] = this.unitPrice;
        data["warehouseId"] = this.warehouseId;
        data["warehouseName"] = this.warehouseName;
        return data;
    }
}

export interface IResponseReplenishmentItemJson {
    productId?: number;
    sku?: string | undefined;
    name?: string | undefined;
    category?: string | undefined;
    uom?: string | undefined;
    currentStock?: number;
    reorderPoint?: number;
    dailyConsumption?: number;
    leadTimeDays?: number;
    suggestedQty?: number;
    isCritical?: boolean;
    unitPrice?: number;
    warehouseId?: number;
    warehouseName?: string | undefined;
}

export class ResponseReplenishmentItemJsonPagedResponse implements IResponseReplenishmentItemJsonPagedResponse {
    items?: ResponseReplenishmentItemJson[] | undefined;
    total?: number;
    page?: number;
    pageSize?: number;

    constructor(data?: IResponseReplenishmentItemJsonPagedResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ResponseReplenishmentItemJson.fromJS(item));
            }
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
        }
    }

    static fromJS(data: any): ResponseReplenishmentItemJsonPagedResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseReplenishmentItemJsonPagedResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        return data;
    }
}

export interface IResponseReplenishmentItemJsonPagedResponse {
    items?: ResponseReplenishmentItemJson[] | undefined;
    total?: number;
    page?: number;
    pageSize?: number;
}

export class ResponseReportsJson implements IResponseReportsJson {
    totalPurchaseOrders?: number;
    totalValuePurchased?: number;
    pendingPurchaseOrders?: number;
    cancelPurchaseOrders?: number;
    recentOrders?: ResponseRecentPurchaseOrderJson[] | undefined;
    topSuppliers?: ResponseTopSupplierJson[] | undefined;

    constructor(data?: IResponseReportsJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalPurchaseOrders = _data["totalPurchaseOrders"];
            this.totalValuePurchased = _data["totalValuePurchased"];
            this.pendingPurchaseOrders = _data["pendingPurchaseOrders"];
            this.cancelPurchaseOrders = _data["cancelPurchaseOrders"];
            if (Array.isArray(_data["recentOrders"])) {
                this.recentOrders = [] as any;
                for (let item of _data["recentOrders"])
                    this.recentOrders!.push(ResponseRecentPurchaseOrderJson.fromJS(item));
            }
            if (Array.isArray(_data["topSuppliers"])) {
                this.topSuppliers = [] as any;
                for (let item of _data["topSuppliers"])
                    this.topSuppliers!.push(ResponseTopSupplierJson.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResponseReportsJson {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseReportsJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalPurchaseOrders"] = this.totalPurchaseOrders;
        data["totalValuePurchased"] = this.totalValuePurchased;
        data["pendingPurchaseOrders"] = this.pendingPurchaseOrders;
        data["cancelPurchaseOrders"] = this.cancelPurchaseOrders;
        if (Array.isArray(this.recentOrders)) {
            data["recentOrders"] = [];
            for (let item of this.recentOrders)
                data["recentOrders"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.topSuppliers)) {
            data["topSuppliers"] = [];
            for (let item of this.topSuppliers)
                data["topSuppliers"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IResponseReportsJson {
    totalPurchaseOrders?: number;
    totalValuePurchased?: number;
    pendingPurchaseOrders?: number;
    cancelPurchaseOrders?: number;
    recentOrders?: ResponseRecentPurchaseOrderJson[] | undefined;
    topSuppliers?: ResponseTopSupplierJson[] | undefined;
}

export class ResponseStockItemJson implements IResponseStockItemJson {
    id?: number;
    productName?: string | undefined;
    warehouseName?: string | undefined;
    quantity?: number;
    updatedAt?: Date;
    createdByUserId?: number;
    createdByName?: string | undefined;

    constructor(data?: IResponseStockItemJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.productName = _data["productName"];
            this.warehouseName = _data["warehouseName"];
            this.quantity = _data["quantity"];
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : undefined as any;
            this.createdByUserId = _data["createdByUserId"];
            this.createdByName = _data["createdByName"];
        }
    }

    static fromJS(data: any): ResponseStockItemJson {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseStockItemJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["productName"] = this.productName;
        data["warehouseName"] = this.warehouseName;
        data["quantity"] = this.quantity;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        data["createdByUserId"] = this.createdByUserId;
        data["createdByName"] = this.createdByName;
        return data;
    }
}

export interface IResponseStockItemJson {
    id?: number;
    productName?: string | undefined;
    warehouseName?: string | undefined;
    quantity?: number;
    updatedAt?: Date;
    createdByUserId?: number;
    createdByName?: string | undefined;
}

export class ResponseSupplierJson implements IResponseSupplierJson {
    id?: number;
    name?: string | undefined;
    contact?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
    address?: string | undefined;
    createdByName?: string | undefined;

    constructor(data?: IResponseSupplierJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.contact = _data["contact"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.address = _data["address"];
            this.createdByName = _data["createdByName"];
        }
    }

    static fromJS(data: any): ResponseSupplierJson {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseSupplierJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["contact"] = this.contact;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["address"] = this.address;
        data["createdByName"] = this.createdByName;
        return data;
    }
}

export interface IResponseSupplierJson {
    id?: number;
    name?: string | undefined;
    contact?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
    address?: string | undefined;
    createdByName?: string | undefined;
}

export class ResponseSupplierJsonPagedResponse implements IResponseSupplierJsonPagedResponse {
    items?: ResponseSupplierJson[] | undefined;
    total?: number;
    page?: number;
    pageSize?: number;

    constructor(data?: IResponseSupplierJsonPagedResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ResponseSupplierJson.fromJS(item));
            }
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
        }
    }

    static fromJS(data: any): ResponseSupplierJsonPagedResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseSupplierJsonPagedResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        return data;
    }
}

export interface IResponseSupplierJsonPagedResponse {
    items?: ResponseSupplierJson[] | undefined;
    total?: number;
    page?: number;
    pageSize?: number;
}

export class ResponseSupplierProductJson implements IResponseSupplierProductJson {
    productId?: number;
    productName?: string | undefined;
    sku?: string | undefined;
    unitPrice?: number | undefined;

    constructor(data?: IResponseSupplierProductJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.productName = _data["productName"];
            this.sku = _data["sku"];
            this.unitPrice = _data["unitPrice"];
        }
    }

    static fromJS(data: any): ResponseSupplierProductJson {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseSupplierProductJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["productName"] = this.productName;
        data["sku"] = this.sku;
        data["unitPrice"] = this.unitPrice;
        return data;
    }
}

export interface IResponseSupplierProductJson {
    productId?: number;
    productName?: string | undefined;
    sku?: string | undefined;
    unitPrice?: number | undefined;
}

export class ResponseTokensJson implements IResponseTokensJson {
    accessToken?: string | undefined;
    refreshToken?: string | undefined;
    tokenId?: string | undefined;

    constructor(data?: IResponseTokensJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.refreshToken = _data["refreshToken"];
            this.tokenId = _data["tokenId"];
        }
    }

    static fromJS(data: any): ResponseTokensJson {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseTokensJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["refreshToken"] = this.refreshToken;
        data["tokenId"] = this.tokenId;
        return data;
    }
}

export interface IResponseTokensJson {
    accessToken?: string | undefined;
    refreshToken?: string | undefined;
    tokenId?: string | undefined;
}

export class ResponseTopSupplierJson implements IResponseTopSupplierJson {
    supplierName?: string | undefined;
    totalPurchased?: number;

    constructor(data?: IResponseTopSupplierJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.supplierName = _data["supplierName"];
            this.totalPurchased = _data["totalPurchased"];
        }
    }

    static fromJS(data: any): ResponseTopSupplierJson {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseTopSupplierJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["supplierName"] = this.supplierName;
        data["totalPurchased"] = this.totalPurchased;
        return data;
    }
}

export interface IResponseTopSupplierJson {
    supplierName?: string | undefined;
    totalPurchased?: number;
}

export class ResponseUserListItemJson implements IResponseUserListItemJson {
    id?: number;
    name?: string | undefined;
    email?: string | undefined;
    role?: string | undefined;
    active?: boolean;
    createdOn?: Date;

    constructor(data?: IResponseUserListItemJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.email = _data["email"];
            this.role = _data["role"];
            this.active = _data["active"];
            this.createdOn = _data["createdOn"] ? new Date(_data["createdOn"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): ResponseUserListItemJson {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseUserListItemJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["email"] = this.email;
        data["role"] = this.role;
        data["active"] = this.active;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : undefined as any;
        return data;
    }
}

export interface IResponseUserListItemJson {
    id?: number;
    name?: string | undefined;
    email?: string | undefined;
    role?: string | undefined;
    active?: boolean;
    createdOn?: Date;
}

export class ResponseUserProfileJson implements IResponseUserProfileJson {
    name?: string | undefined;
    email?: string | undefined;
    role?: string | undefined;
    active?: boolean;
    createdAt?: Date;

    constructor(data?: IResponseUserProfileJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.email = _data["email"];
            this.role = _data["role"];
            this.active = _data["active"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): ResponseUserProfileJson {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseUserProfileJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["email"] = this.email;
        data["role"] = this.role;
        data["active"] = this.active;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        return data;
    }
}

export interface IResponseUserProfileJson {
    name?: string | undefined;
    email?: string | undefined;
    role?: string | undefined;
    active?: boolean;
    createdAt?: Date;
}

export class ResponseWarehouseJson implements IResponseWarehouseJson {
    id?: number;
    name?: string | undefined;
    location?: string | undefined;
    capacity?: number;
    items?: number;
    utilization?: number;
    createdAt?: Date;
    createdByUserId?: number;
    createdByName?: string | undefined;
    updatedByUserId?: number | undefined;
    updatedByName?: string | undefined;
    updatedAt?: Date | undefined;

    constructor(data?: IResponseWarehouseJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.location = _data["location"];
            this.capacity = _data["capacity"];
            this.items = _data["items"];
            this.utilization = _data["utilization"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.createdByUserId = _data["createdByUserId"];
            this.createdByName = _data["createdByName"];
            this.updatedByUserId = _data["updatedByUserId"];
            this.updatedByName = _data["updatedByName"];
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): ResponseWarehouseJson {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseWarehouseJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["location"] = this.location;
        data["capacity"] = this.capacity;
        data["items"] = this.items;
        data["utilization"] = this.utilization;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["createdByUserId"] = this.createdByUserId;
        data["createdByName"] = this.createdByName;
        data["updatedByUserId"] = this.updatedByUserId;
        data["updatedByName"] = this.updatedByName;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        return data;
    }
}

export interface IResponseWarehouseJson {
    id?: number;
    name?: string | undefined;
    location?: string | undefined;
    capacity?: number;
    items?: number;
    utilization?: number;
    createdAt?: Date;
    createdByUserId?: number;
    createdByName?: string | undefined;
    updatedByUserId?: number | undefined;
    updatedByName?: string | undefined;
    updatedAt?: Date | undefined;
}

export class ResponseWarehouseJsonPagedResponse implements IResponseWarehouseJsonPagedResponse {
    items?: ResponseWarehouseJson[] | undefined;
    total?: number;
    page?: number;
    pageSize?: number;

    constructor(data?: IResponseWarehouseJsonPagedResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ResponseWarehouseJson.fromJS(item));
            }
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
        }
    }

    static fromJS(data: any): ResponseWarehouseJsonPagedResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseWarehouseJsonPagedResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        return data;
    }
}

export interface IResponseWarehouseJsonPagedResponse {
    items?: ResponseWarehouseJson[] | undefined;
    total?: number;
    page?: number;
    pageSize?: number;
}

export class ResponseWarehouseStockItemJson implements IResponseWarehouseStockItemJson {
    productId?: number;
    sku?: string | undefined;
    productName?: string | undefined;
    quantity?: number;
    reorderPoint?: number;
    lastPurchasePrice?: number;

    constructor(data?: IResponseWarehouseStockItemJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.sku = _data["sku"];
            this.productName = _data["productName"];
            this.quantity = _data["quantity"];
            this.reorderPoint = _data["reorderPoint"];
            this.lastPurchasePrice = _data["lastPurchasePrice"];
        }
    }

    static fromJS(data: any): ResponseWarehouseStockItemJson {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseWarehouseStockItemJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["sku"] = this.sku;
        data["productName"] = this.productName;
        data["quantity"] = this.quantity;
        data["reorderPoint"] = this.reorderPoint;
        data["lastPurchasePrice"] = this.lastPurchasePrice;
        return data;
    }
}

export interface IResponseWarehouseStockItemJson {
    productId?: number;
    sku?: string | undefined;
    productName?: string | undefined;
    quantity?: number;
    reorderPoint?: number;
    lastPurchasePrice?: number;
}

export class SwaggerException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new SwaggerException(message, status, response, headers, null);
}